// Package root exists as the os/tempfile.go & os/root.go do not play nicely together because go really likes to
// half-ass new types & features.
//
// It is essentially os/tempfile.go plus a wrapper for os.Root that allows CreateTemp and MkdirTemp to be called on it,
// forcing any temp files created using it to respect the os.Root path restrictions.
package root

import (
	"errors"
	_ "errors"
	"fmt"
	"os"
	"path/filepath"
	_ "unsafe" // for go:linkname
)

// pathEscapes is the error message for os.errPathEscapes since it's not exported & we therefore can't errors.Is it
const pathEscapes = "path escapes from parent"

// Root is a simple wrapper for os.Root to allow it to create temp files
type Root struct {
	*os.Root
}

// OpenRoot wraps the os.Root OpenRoot call
func OpenRoot(dir string) (*Root, error) {
	r, err := os.OpenRoot(dir)
	if err != nil {
		return nil, err
	}

	return &Root{r}, nil
}

// OpenRoot opens a new Root instance under the existing Root.
// It's not a strict wrapper to os.Root.OpenRoot as that function loses the full filepath, which we need for os.Rename
// and os.CreateTemp
func (r *Root) OpenRoot(dir string) (*Root, error) {
	// Don't use this as we lose the full path, which makes os.Rename and the rest break
	if nr, err := r.Root.OpenRoot(dir); err != nil {
		return nil, err
	} else {
		_ = nr.Close() // We only used this to make certain we weren't escaping any paths, etc
	}
	nr, err := os.OpenRoot(filepath.Join(r.Name(), dir))
	if err != nil {
		return nil, err
	}

	return &Root{nr}, nil
}

// Rename is a wrapper for os.Rename that forces the oldpath & newpath to be located under the Root object
// See [os.Rename] for more info.
func (r *Root) Rename(oldpath, newpath string) error {
	_, err := r.Lstat(oldpath)
	if err != nil && errors.Unwrap(err).Error() == pathEscapes {
		return fmt.Errorf("oldpath: %w", err)
	}
	_, err = r.Lstat(newpath)
	_ = errors.Unwrap(err)
	if err != nil && errors.Unwrap(err).Error() == pathEscapes {
		return fmt.Errorf("newpath: %w", err)
	}

	return os.Rename(filepath.Join(r.Name(), oldpath), filepath.Join(r.Name(), newpath))
}

// random number source provided by runtime.
// We generate random temporary file names so that there's a good
// chance the file doesn't exist yet - keeps the number of tries in
// TempFile to a minimum.
//
//go:linkname runtime_rand runtime.rand
func runtime_rand() uint64

func nextRandom() string {
	return uitoa(uint(uint32(runtime_rand())))
}

// CreateTemp creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting file.
// The filename is generated by taking pattern and adding a random string to the end.
// If pattern includes a "*", the random string replaces the last "*".
// The file is created with mode 0o600 (before umask).
// If dir is the empty string, CreateTemp uses the top level directory.
// Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
// The caller can use the file's Name method to find the pathname of the file.
// It is the caller's responsibility to remove the file when it is no longer needed.
func (r *Root) CreateTemp(dir, pattern string) (*os.File, error) {
	if dir == "" {
		dir = "./" // Can't rely on os.TempDir() as it might not be under the root. As a hack, use the current directory instead
	}

	prefix, suffix, err := prefixAndSuffix(pattern)
	if err != nil {
		return nil, &os.PathError{Op: "createtemp", Path: pattern, Err: err}
	}
	prefix = joinPath(dir, prefix)

	try := 0
	for {
		name := prefix + nextRandom() + suffix
		f, err := r.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)
		if os.IsExist(err) {
			if try++; try < 10000 {
				continue
			}
			return nil, &os.PathError{Op: "createtemp", Path: prefix + "*" + suffix, Err: os.ErrExist}
		}
		return f, err
	}
}

var errPatternHasSeparator = errors.New("pattern contains path separator")

// prefixAndSuffix splits pattern by the last wildcard "*", if applicable,
// returning prefix as the part before "*" and suffix as the part after "*".
func prefixAndSuffix(pattern string) (prefix, suffix string, err error) {
	for i := 0; i < len(pattern); i++ {
		if os.IsPathSeparator(pattern[i]) {
			return "", "", errPatternHasSeparator
		}
	}
	if pos := lastIndexByteString(pattern, '*'); pos != -1 {
		prefix, suffix = pattern[:pos], pattern[pos+1:]
	} else {
		prefix = pattern
	}
	return prefix, suffix, nil
}

// MkdirTemp creates a new temporary directory in the directory dir
// and returns the pathname of the new directory.
// The new directory's name is generated by adding a random string to the end of pattern.
// If pattern includes a "*", the random string replaces the last "*" instead.
// The directory is created with mode 0o700 (before umask).
// If dir is the empty string, MkdirTemp uses the top level directory.
// Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
// It is the caller's responsibility to remove the directory when it is no longer needed.
func (r *Root) MkdirTemp(dir, pattern string) (string, error) {
	if dir == "" {
		dir = "./" // Can't rely on os.TempDir() as it might not be under the root. As a hack, use the current directory instead
	}

	prefix, suffix, err := prefixAndSuffix(pattern)
	if err != nil {
		return "", &os.PathError{Op: "mkdirtemp", Path: pattern, Err: err}
	}
	prefix = joinPath(dir, prefix)

	try := 0
	for {
		name := prefix + nextRandom() + suffix
		err := r.Mkdir(name, 0700)
		if err == nil {
			return name, nil
		}
		if os.IsExist(err) {
			if try++; try < 10000 {
				continue
			}
			return "", &os.PathError{Op: "mkdirtemp", Path: dir + string(os.PathSeparator) + prefix + "*" + suffix, Err: os.ErrExist}
		}
		if os.IsNotExist(err) {
			if _, err := r.Stat(dir); os.IsNotExist(err) {
				return "", err
			}
		}
		return "", err
	}
}

func joinPath(dir, name string) string {
	if len(dir) > 0 && os.IsPathSeparator(dir[len(dir)-1]) {
		return dir + name
	}
	return dir + string(os.PathSeparator) + name
}

func lastIndexByteString(s string, c byte) int {
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == c {
			return i
		}
	}
	return -1
}

// uitoa converts val to a decimal string.
func uitoa(val uint) string {
	if val == 0 { // avoid string allocation
		return "0"
	}
	var buf [20]byte // big enough for 64bit value base 10
	i := len(buf) - 1
	for val >= 10 {
		q := val / 10
		buf[i] = byte('0' + val - q*10)
		i--
		val = q
	}
	// val < 10
	buf[i] = byte('0' + val)
	return string(buf[i:])
}
